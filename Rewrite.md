# TheNerdProject Rewrite Plan!

Note: The headings are a template generated by ChatGPT.
I do not use code generated by LLMs for purposes other than learning.

## 1. Introduction:

- Introduce the Nerd game engine and its main objectives.

    Nerd is a game engine based on the Processing creative-coding framework that makes it   fast and convenient to make complex applications with Processing. This is done with a focus on making the user's code need less changes for introducing new features into the engine, to allow easier prototyping and easier, fun development!

    Nerd also focuses on being a complex enough project for beginners who've used Processing for artwork, to dive into designing software.

- Explain the motivation behind the engine's development and the need for a rewrite.

    Nerd is built by me, Brahvim, all alone, and is developed out of a passion for software architecture and API design! Nerd does not really need a rewrite, but after having been rewritten thrice for its first 2 years (or, well, *my life's* past 2 years! I'm currently 17 years old) of development it has seen, it has always had nice APIs been integrated into it.

    However, since I haven't worked on Nerd for the past 3 months, I have felt the need to rewrite a few significant portions of the engine (as well as rewrite messed up projects it depends on, such as the OpenAL module - which isn't needed for Nerd to function, but hey - a three month burnout break broken with a restart? ...could be a good idea, right?!).

    Nerd is my current, and first 20k line project. Before this, I'd rewritten an Android app that was ~6k lines, developed over the last 4 wintery months of 2021 (also based on Processing!) in 4 days, borrowing little from the architecture of what was left, and only *somewhat* from what was already written. The rewrite for this app felt quite incomplete without the presence of "nice APIs to handle game engine things!", such as... the scenes API in Nerd. ...since switching Android activities would also mean putting even more time starting a Processing sketch per activity. I just decided to write Nerd instead of learning to use Android UI tools since OpenGL is definitely a better one over custom UI components, no matter they might render faster!

## 2. Architecture:

- Provide a high-level overview of the engine's architecture.

    (This has been written by ChatGPT.)

    """
    Step 1: Start by writing your Java `main()` method as usual.

    Step 2: Create an instance of the `NerdSketchBuilder` abstract class.

    Step 3: Override two methods in the `NerdSketchBuilder` class. These allow one to extend or customize a subclass of `NerdSketch` and use that instead of `NerdSketch` itself. This is where a user defines what `NerdModules` are used in by the engine.

    Step 4: Implement methods to add or remove modules from the engine using `NerdModuleSettings` to specify the `java.lang.reflection.Class` and arguments for each `NerdModule`.

    Step 5: For 'scenes' and 'layers', create classes that extend `NerdScene` and `NerdLayer`, respectively. These classes can have fields referencing `NerdModule` instances present in the `NerdSketch` class. For these to be used, the `NerdScenesModule` must be added to the engine, and its `NerdModuleSettings` shall specify the initial scene.
    """

- Describe the core components and their interactions in the system.

    Nerd consists of "`NerdModule`s" that are updated by the `NerdSketch` class, and registered with it using the `NerdSketchBuilder` class. These modules allow adding features to the engine, and can also be used to add, say, custom callbacks (Nerd has evolved from being based entirely on callbacks to this modular system where users add modules made by either me or other developers to bring in library support!).

## 3. Design Principles:

- Detail the guiding design principles and coding standards that will be followed during the rewrite.

    The same coding style and standards will be followed, except, this time I should use SonarLint and not just let it sit around. I shall also find workarounds to some style issues caused by the previous design - such as `NerdScene` classes using this convention where the instance of `NerdSketch` stored in `NerdScene` was named in upper \[Ada\] case without needing being declared as `final`. This rewrite of Nerd should address such style issues by letting users, say, add and remove `NerdModule`s themselves into/from subclasses of `NerdScene` and `NerdLayer` that they want to use as the base class for scenes and layers in their project. This pattern should be made easier to enforce, perhaps through the use of annotations or a similar mechanism that would allow the addition of fields to classes to make them easier to generate. Nerd should use language features to become faster/convenient or easier to develop with, but must certainly *not* add *only unnecessary* boilerplate or complexity!

- Explain the use of design patterns and paradigms for consistency.

    The builder pattern is utilized in quite a few places in the engine. `NerdSketchBuilder` is the best example of this. The use of design patterns that confuse users should and will be kept as low as possible. Inheritance and package-level visibility are to be used carefully, since the previous version of Nerd faced issues with accessing fields in other packages - extending classes in other packages to gain access to otherwise `protected` fields, which breaks encapsulation and has better solutions which I otherwise went for.

## 4. Features and Modules:

- List the features and functionalities the engine will offer.

    In the currently existing version of Nerd, the following `NerdModule`s have complete or nearly complete implementations:
        - `NerdEcsModule`,
        - `NerdInputModule`,
        - `NerdScenesModule`,
        - `NerdWindowModule`,
        - `NerdAssetsModule`,
        - `NerdDisplayModule`,
        - `NerdOpenAlModule` (needs a complete rewrite along with wrapper classes for OpenAL).

- Define the key modules and classes that make up the engine.

    Since the list of existing `NerdModule`s has already been provided, following, are some classes:
            - Classes for the `NerdEcsModule`,
            - Classes for lights available in Processing,
            - Classes for the `NerdWindowModule` and `NerdDisplayModule` to support arguments provided to   `PApplet::size()`,
            - `NerdGenericGraphics` - a wrapper on `PGraphics` that adds methods for convenience.
            - Classes for *function sample generation* for animation that need rewrites, such as `NerdEasingFunction`.
            - Classes for complete networking solutions for TCP and UDP, which already exist.
            - Classes for collision math for rendering, ...and not a complete Physics simulation solution (`NerdModule`s regarding Physics libraries shall exist!).

## 5. Data Structures:

- Describe the data structures that will be employed for storing and managing game data.

    The ECS pattern is what I intend to use to store game data. Nerd already uses `ArrayList`s, `HashSet`s, `LinkedHasSet`s, `Vector`s, `HashMap`s as well as custom classes or fields with long-term duties for holding data for its retrieval. Decisions for using these were taken with respect to what each of said data structures was capable of doing, and what the least requirements for a certain case were. I should also take care to program against interfaces in the rewrite. Having faced my recent experiences with memory allocation in C, I shall also look for cases where I can let a data structure trim its size to de-allocate memory if possible without increasing workload on the JVM or slowing down what it already did quite well. This should also focus on smoothing out allocation and de-allocation of memory, hopefully resulting in smaller waiting times!

- Explain why these specific data structures have been chosen.

    As said earlier, all data structures were chosen based on how closely they matched the least requirements.

## 6. User Interface (UI):

- Outline the design and capabilities of any user interface components within the engine.

    The game engine is supposed to exist as an entity entirely in the form of source code. Game developers can however, inherit from Nerd's existing classes to add support for custom maps et cetera, meaning that there likely won't be any scenario where full access to a game's source code is needed for a feature in the custom editor designed for a game. Nerd could attempt to optimize making editors as well - perhaps through an entirely new framework, since I never actually intended to have an editor for anything, and expected game developers using Nerd to handle this themselves. However, it is true, that handling this is challenging, and that I should focus on making it easier to integrate an editor into Nerd.

## 7. Performance Considerations:

- Discuss strategies and techniques for optimizing the engine's performance.

    Nerd has never felt slow to me. If I carefully focus on making the modules API faster, I might never need to worry about performance! The modular architecture was supposed to be better, at least theoretically. The rewrite should prove if that really is the case.

- Address areas like rendering, memory management, and multi-threading.

    Rendering is handled by Processing, thus mostly outside of Nerd's control. As for any overrides or overloads of functions from the Processing API, I have tested what works fastest for cases such as image rendering or special cases for projection/un-projection where speed generally is known to be a concern. As for memory management, this time, I shall try to spread big allocations/de-allocations so low frame-rates can be combatted with at the lowest level / *root* of their buildup. Nerd utilizes multi-threading for asynchronous asset loading, networking, et cetera. Components that other modules may not need to access from different threads, such as scene data (but not ECS data), may not utilize thread-safe data structures for performance.

## 8. Testing and Quality Assurance:

- Explain the testing approach, including unit testing, integration testing, and user testing.

    Nerd is always going through testing! The main repository includes demo scenes for all features, which are written in a tutorial style so they may serve as documentation.

- Detail how the engine's reliability and stability will be ensured.

    Applications written using Nerd have only crashes in these cases:
        - Bugs or exceptions in code during debugging, implementation of APIs or general testing,
        - Exceptions thrown by Processing's APIs, which cannot be dealt with here,
        - Crashes in native code, such as during the testing of the OpenAL module.
        - Allocation/De-allocation inconsistencies that overloads a system, triggering JVM crashes.

## 9. API Documentation:

- Provide documentation for the engine's API, including class/method descriptions and usage examples.

    Nerd provides documentation mostly through examples and articles that explain in a straightforward manner how something is to be achieved using the engine.

- Mention tools or formats used for creating API documentation.

    Nerd's documentation utilizes JavaDocs, GitHub Markdown, and actual example code that is written with clarity and tutoring in mind as features are developed.

## 10. Development Environment:

- Specify the tools, libraries, and platforms that will be utilized during the rewrite.

    I develop Nerd in VSCode. I may or may not move to IntelliJ IDEA in the future - this is uncertain. Nerd does not use a build system, though for the convenience of game developers using it, solutions using existing build systems (say, Gradle?) may be provided (mostly, putting assets right in the code, or the `R` class as defined by the Android Java SDK's build system). I do not have experience with build systems outside of C/C++ development, therefore I agree to being weak in this area and not seeing any potential use of it.

- Include development and debugging tools.

    Developers may use what they like. Nerd and its modules will always only be provided as JAR files, containing source code.

## 11. Project Timeline:

- Present a rough project timeline with milestones or phases.

            - The first phase is of a rewrite.
            - The next phase will include optimizing the architecture made so far for performance and simplicity.
            - Normal addition of features may resume afterwards.

- Define time-frames for various development stages.

            - The first phase should be completed within 3 months (if I get time off of college work like I used to in other areas of my life!).
            - The optimization stage may take variable time; if the first stage of development does not involve enough care, this stage may change what was present already, creating inconsistencies calling for yet *another* rewrite of some parts, if not the entire engine. Assuming that is taken care of, this phase could end faster, given the optimizations needed to be applied are simple.
            - The last phase can continue for the entirety of the lifetime of Nerd.

## 12. Team Collaboration:

- If applicable, define team roles, responsibilities, and communication channels.

    Nerd does not have a team behind it - it's all just me!
    If I could, I would have *junior* responsibilities, such as implementing classes or systems within them, given a design document. I do not want to let anybody else design Nerd since I want to keep trying out adding new features upto myself. Suggestions are always welcome, but most requests for systems will definitely be unrealistic or demanding, which may not go well with Nerd's 'quick development' / fast prototyping philosophy. GitHub issues, markdown files, example code, a personal IRC (Discord server) for collaborators - these shall be the channels of communication, **only as needed**.

- Describe how team members will collaborate on the project.

    The use of VCS software like Git and web services like GitHub seems to be the best option available.

## 13. Budget and Resources:

- Estimate the budget and resources required for the project.

    Time and care are the only two resources needed for the development of Nerd!

- Identify any external resources or dependencies.

  - GitHub repository space.
  - Processing, and its dependencies.
  - Processing libraries, or their integration into modules, if/when needed.
  - Native implementations of APIs like OpenAL. For Nerd, this should be OpenAL Soft.

## 14. Risks and Contingencies:

- Identify potential risks and challenges in the rewrite.

    If not taken care of, the rewrite could result in a potentially slower API, which will not be easy to speed up later on. The optimization phase exists for trivial optimizations, such as better control over the JDK 17 GC, and the additions of dynamic/runtime live optimization techniques for graphics, et cetera (such as, say, mipmaps!).

- Propose strategies to mitigate these risks.

    The rewrite should be done with a clear plan for all APIs that will be included, so that minimal effort is required when implementing them in the rewrite - *no extra design decisions should need be made*. The implementation of existing APIs being rewritten should be straightforward, optimizable (mostly in terms of class fields and language features used). If possible, the architecture of the engine should be optimized and tested before the API for the rewrite is finally known, once and for all.

## 15. Conclusion:

- Summarize the key points of the design document.

    This design document has so far, stressed how Nerd should be rewritten: with a focus on speed of rewriting, rough idea of what code can be borrowed, and what APIs need to be thought out again, freshly. Optimization of these APIs for performance has been concerned and will hopefully not remain to be a concern in the future.

- Provide a sense of what the future holds for the Nerd game engine.

    Nerd is a 'dream project', and what the future holds for Nerd depends on what the contributors decide to do (which, for now, is just me!). Nerd's future should be one where it is continuously filled with new features that respect the original principles of fast prototyping, simple design that is easily explainable and is taught in a way that answers any queries for any complexities that were intentionally put in. I hope that the Processing community will see Nerd as another complex project build on top of Processing, if not an effective, easy, and overall, excellent way to use Processing for large projects.
